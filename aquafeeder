#define blower_pin 2    
#define valve_open_pin 12   // RPWM - Clockwise
#define valve_close_pin 13  // LPWM - Counter-clockwise

#define BLYNK_TEMPLATE_ID "TMPL6okmf04Wj"
#define BLYNK_TEMPLATE_NAME "SMART AQUA FEEDER"
#define BLYNK_AUTH_TOKEN "f33FSB-73GJ61_tvYGoU9V4L1PG2rUlI"
#define BLYNK_PRINT Serial
#include <WiFi.h>
#include <WiFiClient.h>
#include <BlynkSimpleEsp32.h>
#include <time.h>

char ssid[] = "12345678";    
char pass[] = "12345678"; 
BlynkTimer timer; 

#define camera_pin 14

// Blynk virtual pin assignments
#define blower_virtual_pin V0
#define valve_virtual_pin V1
#define camera_virtual_pin V3
#define manual_auto_virtual_pin V4
#define scheduler1_virtual_pin V5
#define scheduler2_virtual_pin V6
#define scheduler3_virtual_pin V7
#define feed_amount_virtual_pin V10
#define feeding_status_virtual_pin V21
#define estimated_biomass_virtual_pin V22
#define remaining_feeds_virtual_pin V23

bool manualMode = false;
int feedAmountSeconds = 5;
bool blowerRunning = false;
double estimatedBiomass = 1500.0;
int remainingFeeds = 75;

// NTP Time settings
const char* ntpServer = "pool.ntp.org";
const long gmtOffset_sec = 8 * 3600;  // GMT+8 for Philippines
const int daylightOffset_sec = 0;

// Scheduler settings
int scheduler1_hour = -1;
int scheduler1_minute = -1;
int scheduler2_hour = -1;
int scheduler2_minute = -1;
int scheduler3_hour = -1;
int scheduler3_minute = -1;

bool scheduler1_triggered = false;
bool scheduler2_triggered = false;
bool scheduler3_triggered = false;

void setup()
{
  Serial.begin(115200);

  WiFi.begin(ssid, pass);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nWiFi connected");

  // Initialize time synchronization
  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
  Serial.println("Waiting for NTP time sync...");
  delay(2000);
  printLocalTime();

  Blynk.config(BLYNK_AUTH_TOKEN);
  Blynk.connect();

  pinMode(blower_pin, OUTPUT);
  pinMode(valve_open_pin, OUTPUT);
  pinMode(valve_close_pin, OUTPUT);
  digitalWrite(blower_pin, LOW);
  digitalWrite(valve_open_pin, LOW);
  digitalWrite(valve_close_pin, LOW);

  // Setup timer to check schedules every second
  timer.setInterval(1000L, checkSchedules);

  Serial.println("Smart AquaFeeder Ready.");
}

void loop()
{
  Blynk.run();
  timer.run();
}

BLYNK_WRITE(manual_auto_virtual_pin) {
  manualMode = param.asInt();
  Serial.print("System mode: ");
  Serial.println(manualMode ? "MANUAL" : "AUTO");
}

BLYNK_WRITE(feed_amount_virtual_pin) {
  int newAmount = param.asInt();
  if (newAmount > 0 && newAmount <= 60) {
    feedAmountSeconds = newAmount;
    Serial.println("Feed amount set to " + String(feedAmountSeconds) + " seconds");
  } else {
    Serial.println("Invalid feed amount. Must be between 1-60 seconds.");
  }
}

// Store the last scheduled times to detect when actual trigger happens
long lastScheduler1Time = 0;
long lastScheduler2Time = 0;
long lastScheduler3Time = 0;

BLYNK_WRITE(scheduler1_virtual_pin) {
  long startTimeInSecs = param[0].asLong();
  
  // Convert seconds to hours and minutes
  scheduler1_hour = startTimeInSecs / 3600;
  scheduler1_minute = (startTimeInSecs % 3600) / 60;
  scheduler1_triggered = false;
  
  Serial.print("SCHEDULER 1 set to: ");
  Serial.print(scheduler1_hour);
  Serial.print(":");
  Serial.println(scheduler1_minute);
}

BLYNK_WRITE(scheduler2_virtual_pin) {
  long startTimeInSecs = param[0].asLong();
  
  // Convert seconds to hours and minutes
  scheduler2_hour = startTimeInSecs / 3600;
  scheduler2_minute = (startTimeInSecs % 3600) / 60;
  scheduler2_triggered = false;
  
  Serial.print("SCHEDULER 2 set to: ");
  Serial.print(scheduler2_hour);
  Serial.print(":");
  Serial.println(scheduler2_minute);
}

BLYNK_WRITE(scheduler3_virtual_pin) {
  long startTimeInSecs = param[0].asLong();
  
  // Convert seconds to hours and minutes
  scheduler3_hour = startTimeInSecs / 3600;
  scheduler3_minute = (startTimeInSecs % 3600) / 60;
  scheduler3_triggered = false;
  
  Serial.print("SCHEDULER 3 set to: ");
  Serial.print(scheduler3_hour);
  Serial.print(":");
  Serial.println(scheduler3_minute);
}

BLYNK_WRITE(blower_virtual_pin) {
  if (!manualMode) return;
  int state = param.asInt();
  digitalWrite(blower_pin, state ? HIGH : LOW);
  Serial.println(String("BLOWER turned ") + (state ? "ON" : "OFF"));
}

BLYNK_WRITE(valve_virtual_pin) {
  if (!manualMode) return;
  
  int state = param.asInt();
  
  if (state == 1) {
    // Turn ON - Rotate Clockwise (Open valve)
    analogWrite(valve_open_pin, 255);   // Full speed clockwise
    analogWrite(valve_close_pin, 0);    // Ensure counter-clockwise is off
    Serial.println("VALVE rotating CLOCKWISE (Opening)");
  } else {
    // Turn OFF - Rotate Counter-clockwise (Close valve)
    analogWrite(valve_open_pin, 0);     // Ensure clockwise is off
    analogWrite(valve_close_pin, 255);  // Full speed counter-clockwise
    Serial.println("VALVE rotating COUNTER-CLOCKWISE (Closing)");
  }
}

BLYNK_CONNECTED() {
  Serial.println("Connected to Blynk!");
  Blynk.virtualWrite(estimated_biomass_virtual_pin, estimatedBiomass);
  Blynk.virtualWrite(remaining_feeds_virtual_pin, remainingFeeds);
  
  // Request current scheduler values from Blynk
  Blynk.syncVirtual(scheduler1_virtual_pin);
  Blynk.syncVirtual(scheduler2_virtual_pin);
  Blynk.syncVirtual(scheduler3_virtual_pin);
}

void printLocalTime() {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    Serial.println("Failed to obtain time");
    return;
  }
  Serial.print("Current time: ");
  Serial.print(timeinfo.tm_hour);
  Serial.print(":");
  Serial.print(timeinfo.tm_min);
  Serial.print(":");
  Serial.println(timeinfo.tm_sec);
}

void checkSchedules() {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    return;
  }
  
  int currentHour = timeinfo.tm_hour;
  int currentMinute = timeinfo.tm_min;
  
  // Check Scheduler 1
  if (scheduler1_hour == currentHour && scheduler1_minute == currentMinute && !scheduler1_triggered) {
    scheduler1_triggered = true;
    Serial.println("SCHEDULER 1 TIME MATCHED!");
    if (!manualMode && !blowerRunning) {
      Serial.println("SCHEDULER 1 FEED STARTING");
      startAutoFeed();
    }
  }
  
  // Reset trigger flag when minute changes
  if (scheduler1_minute != currentMinute) {
    scheduler1_triggered = false;
  }
  
  // Check Scheduler 2
  if (scheduler2_hour == currentHour && scheduler2_minute == currentMinute && !scheduler2_triggered) {
    scheduler2_triggered = true;
    Serial.println("SCHEDULER 2 TIME MATCHED!");
    if (!manualMode && !blowerRunning) {
      Serial.println("SCHEDULER 2 FEED STARTING");
      startAutoFeed();
    }
  }
  
  // Reset trigger flag when minute changes
  if (scheduler2_minute != currentMinute) {
    scheduler2_triggered = false;
  }
  
  // Check Scheduler 3
  if (scheduler3_hour == currentHour && scheduler3_minute == currentMinute && !scheduler3_triggered) {
    scheduler3_triggered = true;
    Serial.println("SCHEDULER 3 TIME MATCHED!");
    if (!manualMode && !blowerRunning) {
      Serial.println("SCHEDULER 3 FEED STARTING");
      startAutoFeed();
    }
  }
  
  // Reset trigger flag when minute changes
  if (scheduler3_minute != currentMinute) {
    scheduler3_triggered = false;
  }
}
























































void startAutoFeed() {
  blowerRunning = true;
  Blynk.virtualWrite(feeding_status_virtual_pin, 1);
  
  // Step 1: Start blower for 2 seconds
  digitalWrite(blower_pin, HIGH);
  Serial.println("AUTO MODE: BLOWER turned ON (pre-feed)");
  
  timer.setTimeout(2000L, []() {
    // Step 2: Open valve (rotate clockwise)
    analogWrite(valve_open_pin, 255);
    analogWrite(valve_close_pin, 0);
    Serial.println("AUTO MODE: VALVE opening (clockwise)");
    
    // Step 3: Wait for set feed amount duration
    timer.setTimeout(feedAmountSeconds * 1000L, []() {
      // Step 4: Close valve (rotate counter-clockwise)
      analogWrite(valve_open_pin, 0);
      analogWrite(valve_close_pin, 255);
      Serial.println("AUTO MODE: VALVE closing (counter-clockwise)");
      
      // Step 5: Stop blower after valve closes
      timer.setTimeout(1000L, []() {
        digitalWrite(blower_pin, LOW);
        analogWrite(valve_open_pin, 0);
        analogWrite(valve_close_pin, 0);
        blowerRunning = false;
        Blynk.virtualWrite(feeding_status_virtual_pin, 0);
        Serial.println("AUTO MODE: Feeding complete - BLOWER OFF, VALVE stopped");
      });
    });
  });
}
